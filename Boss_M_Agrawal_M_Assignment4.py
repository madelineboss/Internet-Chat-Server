"""
Name: Madeline Boss, Mahi Agrawal
Date: 10/27/25
Assignment: 4
Due Date: November 4, 2025
About this project: The goal of this project is to create a functional internet chat server using our knowledge of socket programming and 
networking.
Assumptions: 
All work below was performed solely by Madeline Boss and Mahi Agrawal.
I did not use code generated by an AI tool.
"""
#------To-do List----------------------------------------------------------------------------------------------------------#
"""
status [user] # status for self looks different than others' status
info [Info_text]
block <user>
unblock <user>

other:
    - the !!system!! messages need to be broadcast to everyone, not just the current user
    - figure out how to reuse room numbers
"""

import socket
import sys
import threading
import json
import os

#------Classes----------------------------------------------------------------------------------------------------------#

class User:
    def __init__(self, user, password, info = ""):
        self.username = user
        self.password = password
        self.info = "-"
        self.blocked = []
        self.rooms = []
        self.status = "online"


class Room:
    def __init__(self, roomNum, topic, leader):
        self.roomNum = roomNum
        self.topic = topic
        self.leader = leader
        self.members = [leader]

#-----Initialization-----------------------------------------------------------------------------------------------------#

GOODBYEMSGFILE = "./goodbye.txt"
BEFORELOGINMSGFILE = "./prelogin.txt"
AFTERLOGINMSGFILE = "./afterlogin.txt"
GUESTMSG = "./guest.txt"
USERLOG = "./userFile.txt"
USERSDB = "./users.json"


beforeLoginMsg = ''
goodbyeMsg = ''
afterLoginMsg = ''
guestMsg = ''
userHolding = ''

userList = []
roomList = []
nextRoom = 1
onlineUsers = {}
blockedList = []
userDB = {}

"""
# load list of registered users
def loadUsers():
    global userList
    with open(USERLOG, "r") as f:
        for line in f:
            parts = line.strip().split(' ', 2)
            if len(parts) >= 2:
                user = User(parts[0], parts[1])
                if len(parts) == 3:
                    user.info = parts[2]
                userList.append(user)
"""

def loadUsers():
    global userList
    global blockedList

    if os.path.exists(USERSDB):
        with open(USERSDB, "r") as f:
            USERSDB = json.load(f)

    else:
        usersDB = {}


def loadMsgs():
    global beforeLoginMsg
    global goodbyeMsg
    global afterLoginMsg
    global guestMsg
    
    with open(BEFORELOGINMSGFILE, "r") as f:
        beforeLoginMsg = f.read()
    with open(GOODBYEMSGFILE, "r") as f:
        goodbyeMsg = f.read()
    with open(AFTERLOGINMSGFILE, "r") as f:
        afterLoginMsg = f.read()
    with open(GUESTMSG, "r") as f:
        guestMsg = f.read()
                
n = len(sys.argv)
if (n != 2):
    print("Usage: server_port")
    exit()

loadMsgs()
loadUsers()

#-----Send All Function (Provided)-----------------------------------------------------------------------------------#

# ensure that all bytes of a message are sent over socket (1 if successful, -1 if failed)
def mySendAll(sock, data):
    total_sent = 0
    data_length = len(data)

    try:
        while total_sent < data_length:
            sent = sock.send(data[total_sent:])
            if sent == 0:
                # Socket connection broken
                return -1
            total_sent += sent

    except Exception :
        print("Socket send error in mySendAll.\n")
        return -1

    return 1

#-----Helper Functions---------------------------------------------------------------------------------------------#

# function to find if user already exists
def findUser(user):
    global userList
    for userN in userList:
        if userN.username == user:
            return True
    return False

# function to find if user entered the correct password
def correctPassword(username, password):
    for user in userList:
        if user.username == username:
            if user.password == password:
                return True
    return False

#function to get user object
def getUser(username):
    for user in userList:
        if user.username == username:
            return user
    return None


#-----Chat Command Functions---------------------------------------------------------------------------------------#

# function to list all online users
def who(sock, cmd):
    parts = cmd.split(' ')
    if len(parts) > 1:
        mySendAll(sock, f"Usage: who\n".encode())
        return

    mySendAll(sock, f"{len(onlineUsers)} users online:\n".encode())
    for user in onlineUsers:
        mySendAll(sock, f"{user} ".encode())
    mySendAll(sock, "\n".encode())

# display user information
def status(sock, cmd):
    parts = cmd.split(' ')
    if len(parts) > 2:
        mySendAll(sock, f"Usage: status [user]\n".encode())
        return

    username = parts[1]
    # if user is self, the format is a little different: if no info, print "-" and also print blocked user(s)
    user = None
    for item in userList:
        if item.username == username:
            user = item
            break

    if user is None:
        mySendAll(sock, f"User {username} does not exist.\n".encode())
    else:
        output = f"User: {user.username} \nInfo: {user.info} \nBlocked User(s): {user.blocked} \n{user.status}"
        mySendAll(sock, output.encode())
        mySendAll(sock, "\n".encode())

# start room for a topic
def start(sock, cmd, userName):
    global roomList
    global nextRoom

    parts = cmd.split(' ', 1)
    if len(parts) != 2:
        mySendAll(sock, f"Usage: start <topic>\n".encode())
        return

    topic = parts[1]
    roomNum = nextRoom
    nextRoom += 1

    instance = Room(roomNum, topic, userName)
    roomList.append(instance)
    userObj = getUser(userName)
    userObj.rooms.append(instance)
    # THIS NEEDS TO BE SENT TO EVERYONE ONLINE
    mySendAll(sock, f"!!system!!: {instance.leader} created room {instance.roomNum}, topic: {instance.topic}\n".encode())

# list all rooms
def rooms(sock, cmd):
    parts = cmd.split(' ')
    if len(parts) > 1:
        mySendAll(sock, f"Usage: rooms\n".encode())
        return

    if not roomList:
        mySendAll(sock, "No active rooms\n".encode())
    else:
        mySendAll(sock, f"{len(roomList)} rooms:\n\n".encode())
        for room in roomList:
            message = f"Room {room.roomNum}, topic: {room.topic} \n{len(room.members)} Participant(s): {', '.join(room.members)}\n\n"
            mySendAll(sock, message.encode())

# join a room
def join(sock, cmd, userName):
    parts = cmd.split(' ')
    if len(parts) != 2 or not parts[1].isdigit():
        mySendAll(sock, f"Usage: join <room_number>\n".encode())
        return

    roomNum = int(parts[1])

    room = None
    for r in roomList:
        if r.roomNum == roomNum:
            room = r

    if room is None:
        mySendAll(sock, f"Room {roomNum} does not exist.\n".encode())
    else:
        if userName in room.members:
            mySendAll(sock, f"You are already in Room {roomNum}.\n".encode())
        else:
            room.members.append(userName)
            userObj = getUser(userName)
            userObj.rooms.append(room)
            mySendAll(sock, f"You joined Room {roomNum}.\n".encode())

# leave a room
def leave(sock, cmd, userName):
    global roomList

    parts = cmd.split(' ')
    if len(parts) != 2 or not parts[1].isdigit():
        mySendAll(sock, f"Usage: leave <room_number>\n".encode())
        return

    roomNum = int(parts[1])

    room = None
    for r in roomList:
        if r.roomNum == roomNum:
            room = r

    if room is None:
        mySendAll(sock, f"Room {roomNum} does not exist.\n".encode())
    else:
        if userName not in room.members:
            mySendAll(sock, f"You are not in Room {roomNum}.\n".encode())
        else:
            userObj = getUser(userName)
            if room.leader == userName:
                roomList.remove(room)
                userObj.rooms.remove(room)
                mySendAll(sock, f"!!system!!: Room {roomNum} (topic: {room.topic}) closed\n".encode())
            else:
                room.members.remove(userName)
                userObj.rooms.remove(room)
                mySendAll(sock, f"You left Room {roomNum}.\n".encode())

#function to allow users to add info to their profile
def info(sock, cmd, userName):
    parts = cmd.split(' ', 1)
    word, message = parts

    if len(parts) < 2:
        mySendAll(sock, "Usage: info <message>.\n".encode())
    
    else:
        userObj = getUser(userName)
        userObj.info = message
        mySendAll(sock, "Your info has been updated.\n".encode())

# broadcast a message to everyone online
def shout(sock, cmd, userName):
    parts = cmd.split(' ', 1)
    if len(parts) < 2:
        mySendAll(sock, f"Usage: shout <message>.\n".encode())
        return

    word, message = parts

    for userSock in onlineUsers.values():
        mySendAll(userSock, f"\n!!{userName}!!: {message}\n".encode())

# send a message to a specific user
def tell(userName, sock, cmd, cmdCount):
    parts = cmd.split(' ', 2)
    if len(parts) < 3:
        mySendAll(sock, f"Usage: tell <user> <message>.\n".encode())
    else:
        word, target, message = parts
        for user in onlineUsers:
            if user == target:
                userSock = onlineUsers[target]
                mySendAll(userSock, f"{userName}: {message}\n".encode())
            
        if target not in onlineUsers:
            mySendAll(sock, "User is not online.\n".encode())

# send a message to everyone in a room
def say(sock, cmd, userName):
    parts = cmd.split(' ', 2)
    if len(parts) < 3:
        mySendAll(sock, f"Usage: say <room_number> <Msg>\n".encode())
        return
    
    roomNum = int(parts[1])
    message = parts[2]

    room = None
    for r in roomList:
        if r.roomNum == roomNum:
            room = r
    if room is None:
        mySendAll(sock, f"Room {roomNum} does not exist.\n".encode())
    else:
        if userName not in room.members:
            mySendAll(sock, f"You are not in Room {roomNum}.\n".encode())
        else:
            for user in room.members:
                if user in onlineUsers:
                    userSock = onlineUsers[user]
                    mySendAll(userSock, f"[Room {roomNum}] *{userName}*: {message}\n".encode())
    


def block(sock, cmd, userName):
    parts = cmd.split()
    if len(parts) < 2:
        mySendAll(sock, f"Usage: block <user>.\n".encode())
    else:
        target = parts[1]
        userObj = getUser(userName)

        if userObj is None:
            mySendAll(sock, f"Error: current user nout found.\n".encode())

        else:
            blockedList = userObj.blocked
            print("Check")

            if target in blockedList:
                mySendAll(sock, f"User {target} is already blocked.\n".encode())
                print("Check if target in blockedlist")
            else:
                blockedList.append(target)
                print("Check append target to blocked list")
                mySendAll(sock, f"Users {target} has been blocked.\n".encode())



#help function to display all possible commands
def help(sock, cmd):
    parts = cmd.split(' ')
    if len(parts) > 1:
        mySendAll(sock, f"Usage: help\n".encode())
        return
    mySendAll(sock, afterLoginMsg.encode())

# registration function
def register(sock, cmd):
    global userList
    global onlineUsers

    parts = cmd.split(' ')
    if len(parts) != 3:
        mySendAll(sock, f"Usage: register <user> <passwd>\n".encode())
        return

    userName = parts[1]
    password = parts[2]

    flag = findUser(userName) #check if username exists
    if flag == False: #if does not exist, create instance
        instance = User(userName, password)
        userList.append(instance)

        with open(USERLOG, "a") as f: 
            f.write(f"{userName} {password}\n")

        mySendAll(sock, f"User {userName} registered\n".encode())
    #if not, tell guest
    else:
        mySendAll(sock, f"Sorry, username '{userName}' is taken.\n".encode())

    mySendAll(sock, guestMsg.encode())


#------Process Commands------------------------------------------------------------------------------------------------#
def processCmd(userName, sock, cmd, cmdCount):
    print(f"process '{cmd}' from {userName}")

    command = cmd.split(' ')[0]

    if command == "who":
        who(sock, cmd)
    elif command == "status":
        status(sock, cmd)
    elif command == "start":
        start(sock, cmd, userName)
    elif command == "rooms":
        rooms(sock, cmd)
    elif command == "join":
        join(sock, cmd, userName)
    elif command == "leave":
        leave(sock, cmd, userName)
    elif command == "say":
        say(sock, cmd, userName)
    elif command == "help":
        help(sock, cmd)
    elif command == "info":
        info(sock, cmd, userName)
    elif command == "register":
        register(sock, cmd)
    elif command == "shout":
        shout(sock, cmd, userName)
    elif command == "block":
        block(sock, cmd, userName)
    elif command == "tell":
        tell(userName, sock, cmd, cmdCount)
    else:
        mySendAll(sock, "Sorry, that command is not supported.".encode())


#------Handle a Single Client Connection----------------------------------------------------------------------------------#
def handleOneClient(sock):

    # send pre-login message
    mySendAll(sock, beforeLoginMsg.encode())
    mySendAll(sock, "Enter your username: ".encode())

    # receive username from client
    data1 = sock.recv(1000)
    if (len(data1) == 0) :
        sock.close()
        return
    
    data2 = data1.decode().split(' ')[0]
    userName = data2.replace("\t", " ").replace("\n", "").replace("\r", "")

    flag = findUser(userName)
    if flag == True:

        # verify correct password
        mySendAll(sock, "Enter your password: ".encode())

        dataPass = sock.recv(1000)
        if (len(dataPass) == 0):
            sock.close()
            return
        data2Pass = dataPass.decode().split(' ')[0]
        password = data2Pass.replace("\t", " ").replace("\n", "").replace("\r", "")

        if correctPassword(userName, password):

            # send welcome message
            str = f"Welcome to the Internet Chat Room, {userName}!\n\n"
            onlineUsers[userName] = sock
            userObj = getUser(userName)
            userObj.status = "online"
            mySendAll(sock, str.encode())


            mySendAll(sock, afterLoginMsg.encode())

            # initialize prompt and enter command loop
            cmdCount = 0
            mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())
        
            # command loop
            while True: # waits for command from user
                data = sock.recv(1000)
                if (len(data) == 0):
                    print("Client closed connection")
                    sock.close()
                    break

                # decodes and cleans the command
                cmd = data.decode().replace("\t", "").replace("\n", "").replace("\r", "")
                tmp = cmd.split()
                command = cmd.split()[0].lower()

                # if the command is quit or exit, send goodbye message and close socket
                if (command == 'quit' or command == 'exit'):
                    if userName in onlineUsers:
                        del onlineUsers[userName]

                    userObj = getUser(userName)
                    userObj.status = "offline"

                    mySendAll(sock, goodbyeMsg.encode())
                    sock.close()
                    break

                # else, process the command using processCmd()
                else: 
                    processCmd(userName, sock, cmd, cmdCount)

                # send prompt
                cmdCount = cmdCount + 1
                mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())

        else:
            # User entered an incorrect password
            mySendAll(sock, "Login fail: incorrect password\n".encode())
            sock.close()
            return

    else:
        #send guest message
        mySendAll(sock, guestMsg.encode())

        cmdCount = 0
        mySendAll(sock, f"<guest:{cmdCount}>".encode())

        while True:
            data = sock.recv(1000)
            if (len(data) == 0):
                print("Client closed connection")
                sock.close()
                break

            # decodes and cleans the command
            cmd = data.decode().replace("\t", "").replace("\n", "").replace("\r", "")
            tmp = cmd.split()
            command = cmd.split()[0].lower()

            # if the command is quit or exit, send goodbye message and close socket
            if (command == 'quit' or command == 'exit'):
                mySendAll(sock, goodbyeMsg.encode())
                sock.close()
                break

            elif command == "register":
                register(sock, cmd)
                
            else:
                mySendAll(sock, guestMsg.encode())

            cmdCount += 1
            mySendAll(sock, f"<guest:{cmdCount}>".encode())       


def gethostname():
    return socket.gethostname()

#------Main Server Loop--------------------------------------------------------------------------------------------------#
s = socket.socket()
h = gethostname()
print(sys.argv[0], sys.argv[1])

s.bind((h, int(sys.argv[1])))
s.listen(5)
        
while True:
    sock, addr = s.accept()
    print("Receive client connection from ", addr)
    p = threading.Thread(target=handleOneClient, args=(sock,), daemon = True)
    p.start()
    
