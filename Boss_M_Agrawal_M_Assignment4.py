"""
Name: Madeline Boss, Mahi Agrawal
Date: 10/27/25
Assignment: 4
Due Date: November 4, 2025
About this project: The goal of this project is to create a functional internet chat server using our knowledge of socket programming and 
networking.
Assumptions: 
All work below was performed solely by Madeline Boss and Mahi Agrawal.
I did not use code generated by an AI tool.
"""

import socket
import sys
import threading
#------User Class-------------------------------------------------------------------------------------------------------#

class User:
    def __init__(self, user, password, info = ""):
        self.username = user
        self.password = password
        self.info = info
        self.status = "online"

#-----Message Display Initialization-------------------------------------------------------------------------------------#

GOODBYEMSGFILE = "./goodbye.txt"
BEFORELOGINMSGFILE = "./prelogin.txt"
AFTERLOGINMSGFILE = "./afterlogin.txt"
GUESTMSG = "./guest.txt"
USERLOG = "./userFile.txt"

beforeLoginMsg = ''
goodbyeMsg = ''
afterLoginMsg = ''
guestMsg = ''
userHolding = ''

userList = []

def loadMsgs():
    global beforeLoginMsg
    global goodbyeMsg
    global afterLoginMsg
    global guestMsg
    
    with open(BEFORELOGINMSGFILE, "r") as f:
        beforeLoginMsg = f.read()
    with open(GOODBYEMSGFILE, "r") as f:
        goodbyeMsg = f.read()
    with open(AFTERLOGINMSGFILE, "r") as f:
        afterLoginMsg = f.read()
    with open(GUESTMSG, "r") as f:
        guestMsg = f.read()
                
n = len(sys.argv)
if (n != 2):
    print("Usage: server_port")
    exit()

loadMsgs()

#-----Send All Function (Provided)-----------------------------------------------------------------------------------#

# ensure that all bytes of a message are sent over socket (1 if successful, -1 if failed)
def mySendAll(sock, data):
    total_sent = 0
    data_length = len(data)

    try:
        while total_sent < data_length:
            sent = sock.send(data[total_sent:])
            if sent == 0:
                # Socket connection broken
                return -1
            total_sent += sent

    except Exception :
        print("Socket send error in mySendAll.\n")
        return -1

    return 1

#-----Helper Functions---------------------------------------------------------------------------------------------#

# function to find if user already exists
def findUser(user):
    global userList
    for userN in userList:
        if userN.userName == user:
            return True
    return False

#-----Chat Command Functions---------------------------------------------------------------------------------------#

# function to list all online users
def who():
    mySendAll(sock, f"{len(userList)} users online:\n\n".encode())
    for user in userList:
        userName = f"{user.username} "
        mySendAll(sock, userName.encode())
    mySendAll(sock, "\n".encode())

# display user information
def status(cmd):
    print("HERE2")
    username = cmd.split(' ')[1]
    # if user is self, the format is a little different: if no info, print "-" and also print blocked user(s)
    user = None
    for item in userList:
        if item.username == username:
            user = item
            break

    if user is None:
        mySendAll(sock, f"User {username} does not exist.\n".encode())
    else:
        output = f"User: {user.username} \nInfo: {user.info} \n{user.status}"
        mySendAll(sock, output.encode())
        mySendAll(sock, "\n".encode())

#help function to display all possible commands
def help():
    mySendAll(sock, afterLoginMsg.encode())

# registration function
def register(cmd):
    global userList
    word, userName, password = cmd.split(' ')
    #check if username exists
    flag = findUser(userName)
    #if does not exist, create instance
    if flag == False:
        instance = User(userName, password)
        userList.append(instance)
        mySendAll(sock, f"User {userName} registered\n")
    #if not, tell guest
    else:
        print("Username taken")

    mySendAll(sock, afterLoginMsg.encode())

# processes command
def processCmd(userName, sock, cmd):
    print(f"process '{cmd}' from {userName}")

    command = cmd.split(' ')[0]

    if command == "who":
        who()
    elif command == "status":
        print("HERE")
        status(cmd)
    elif command == "register":
        register(cmd)

    # perform according to the cmd, echo for now
    # mySendAll(sock, f"Server response to '{cmd}'\n".encode())

# handles a single client connection
def handleOneClient(sock):

    # send pre-login message
    mySendAll(sock, beforeLoginMsg.encode())
    mySendAll(sock, "Enter your username: ".encode())

    # receive username from client
    data1 = sock.recv(1000)
    if (len(data1) == 0) :
        sock.close()
        return
    
    data2 = data1.decode().split(' ')[0]
    userName = data2.replace("\t", " ").replace("\n", "").replace("\r", "")

    flag = findUser(userName)
    if flag == True:
        # send welcome message
        str = f"Welcome to the Internet Chat Room, {userName}!\n\n"
        mySendAll(sock, str.encode())


        mySendAll(sock, afterLoginMsg.encode())

        # initialize prompt and enter command loop
        cmdCount = 0
        mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())
    
        # command loop
        while True: # waits for command from user
            data = sock.recv(1000)
            if (len(data) == 0):
                print("Client closed connection")
                sock.close()
                break

            # decodes and cleans the command
            cmd = data.decode().replace("\t", "").replace("\n", "").replace("\r", "")
            tmp = cmd.split()
            command = cmd.split()[0].lower()

            # if the command is quit or exit, send goodbye message and close socket
            if (command == 'quit' or command == 'exit'):
                mySendAll(sock, goodbyeMsg.encode())
                sock.close()
                break

            elif command == 'help':
                help()

            elif command == 'register':
                register(data)


            # else, process the command using processCmd()
            else: 
                processCmd(userName, sock, cmd)

            # send prompt
            cmdCount = cmdCount + 1
            mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())

    else:
        #send guest message
        mySendAll(sock, guestMsg.encode())

        cmdCount = 0
        mySendAll(sock, f"<guest:{cmdCount}>".encode())

        while True:
            data = sock.recv(1000)
            if (len(data) == 0):
                print("Client closed connection")
                sock.close()
                break

            # decodes and cleans the command
            cmd = data.decode().replace("\t", "").replace("\n", "").replace("\r", "")
            tmp = cmd.split()
            command = cmd.split()[0].lower()

            # if the command is quit or exit, send goodbye message and close socket
            if (command == 'quit' or command == 'exit'):
                mySendAll(sock, goodbyeMsg.encode())
                sock.close()
                break

            elif command == register:
                register(data)
                

            else:
                mySendAll(sock, guestMsg.encode())

            cmdCount += 1
            mySendAll(sock, f"<guest:{cmdCount}>".encode())       


def gethostname():
    return socket.gethostname()

# main server loop
s = socket.socket()
h = gethostname()
print(sys.argv[0], sys.argv[1])

s.bind((h, int(sys.argv[1])))
s.listen(5)
        
while True:
    sock, addr = s.accept()
    print("Receive client connection from ", addr)
    p = threading.Thread(target=handleOneClient, args=(sock,), daemon = True)
    p.start()
    
